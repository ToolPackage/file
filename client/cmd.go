package internal

import (
	"fmt"
	"github.com/ToolPackage/fse/common/utils"
	c "github.com/fatih/color"
	"github.com/olekukonko/tablewriter"
	uuid "github.com/satori/go.uuid"
	"io/ioutil"
	"os"
	"path/filepath"
	"strings"
	"time"
)

var Opts Commands
var client = NewClient()

type Commands struct {
	List       ListSubCommands       `command:"ls" description:"list all files in fse server"`
	Push       PushSubCommands       `command:"push" description:"upload file(s) to fse server"`
	Pull       PullSubCommands       `command:"pull" description:"download file(s) from fse server"`
	Delete     DeleteSubCommands     `command:"del" description:"delete file(s) in fse server"`
	Connection ConnectionSubCommands `command:"conn" description:"manage fse server connections"`
	Version    VersionSubCommands    `command:"version" description:"print client build version"`
}

type BaseCommand struct {
	Cwd string `long:"cwd" description:"set current work directory" required:"false"`
}

type ListSubCommands struct {
	BaseCommand
}

type PushSubCommands struct {
	BaseCommand
	File string `short:"f" long:"file" description:"file to be pushed to server" required:"true"`
}

type PullSubCommands struct {
	BaseCommand
	File   string `short:"f" long:"file" description:"file to be pulled from server" required:"true"`
	Target string `short:"t" long:"target" description:"target file path" required:"false"`
}

type DeleteSubCommands struct {
	BaseCommand
	File string `short:"f" long:"file" description:"file to be pulled from server" required:"true"`
}

type ConnectionSubCommands struct {
	Peek   ConnectionPeekSubCommands   `command:"peek" description:"choose one connection as current one"`
	List   ConnectionListSubCommands   `command:"ls" description:"list all connections"`
	Add    ConnectionAddSubCommands    `command:"add" description:"add new connection"`
	Remove ConnectionRemoveSubCommands `command:"rm" description:"remove connection"`
}

type ConnectionPeekSubCommands struct {
	Name string `short:"n" long:"name" description:"connection name"`
}

type ConnectionListSubCommands struct {
}

type ConnectionAddSubCommands struct {
	Name       string `short:"n" long:"name" description:"connection name" required:"false"`
	ServerAddr string `short:"s" long:"server" description:"fse server address (example: localhost:9330)" required:"true"`
	Token      string `short:"t" long:"token" description:"access token generated by fse server" required:"true"`
}

type ConnectionRemoveSubCommands struct {
	Name string `short:"n" long:"name" description:"connection name" required:"true"`
}

type VersionSubCommands struct {
}

func (l *ListSubCommands) Execute(args []string) error {
	if err := client.login(); err != nil {
		return err
	}

	files, err := client.listFiles(l.Cwd)
	if err != nil {
		return err
	}

	printFileInfoList(files)
	return nil
}

func (p *PushSubCommands) Execute(args []string) error {
	if err := client.login(); err != nil {
		return err
	}

	filename := filepath.Join("/", p.Cwd, p.File)
	contentType := "unknown"
	content, err := ioutil.ReadFile(p.File)
	if err != nil {
		return err
	}

	file, err := client.uploadFile(filename, contentType, content)
	if err != nil {
		return err
	}
	fmt.Printf("Upload succeed: %s %s %s %s %s",
		file.FileId, file.FileName, file.ContentType,
		time.Unix(0, file.CreatedAt).Format(time.RFC822), utils.ByteCountSI(file.FileSize))
	return nil
}

func (p *PullSubCommands) Execute(args []string) error {
	if err := client.login(); err != nil {
		return err
	}

	filename := filepath.Join("/", p.Cwd, p.File)
	data, err := client.downloadFile(filename)
	if err != nil {
		return err
	}

	if len(p.Target) == 0 {
		p.Target = filepath.Join(p.Target, p.File)
	}

	return ioutil.WriteFile(p.Target, data, 0644)
}

func (d *DeleteSubCommands) Execute(args []string) error {
	if err := client.login(); err != nil {
		return err
	}

	filename := filepath.Join("/", d.Cwd, d.File)
	return client.deleteFile(filename)
}

func (c *ConnectionPeekSubCommands) Execute(args []string) error {
	cred, err := lookupCredential(c.Name)
	if err != nil {
		return err
	}

	client.setConnection(cred[0].TargetName[4:])
	return nil
}

func (c *ConnectionListSubCommands) Execute(args []string) error {
	creds, err := getAllCredentials()
	if err != nil {
		return err
	}

	table := tablewriter.NewWriter(os.Stdout)
	table.SetHeader([]string{"Name", "Server Address", "Last Written"})
	table.SetBorders(tablewriter.Border{Left: true, Top: false, Right: true, Bottom: false})
	table.SetCenterSeparator("|")
	for _, cred := range creds {
		table.Append([]string{cred.TargetName[4:], cred.UserName, cred.LastWritten.Format(time.RFC822)})
	}
	table.Render()

	return nil
}

func (c *ConnectionAddSubCommands) Execute(args []string) error {
	credName := strings.Trim(c.Name, " \t\r\n")
	if len(credName) == 0 {
		credName = uuid.NewV4().String()
		fmt.Println("connection name not provided, using generated name:", credName)
	}
	return addCredential(credName, c.ServerAddr, []byte(c.Token))
}

func (c *ConnectionRemoveSubCommands) Execute(args []string) error {
	return removeCredential(c.Name)
}

func (v *VersionSubCommands) Execute(args []string) error {
	var buf strings.Builder
	buf.WriteRune('[')
	buf.WriteString(c.RedString(name))
	buf.WriteString(c.GreenString(" v%s", version))
	buf.WriteRune('-')
	buf.WriteString(c.GreenString("%s", buildId))
	buf.WriteString("]\n")
	buf.WriteString(description)
	buf.WriteRune('\n')
	buf.WriteString("See: ")
	buf.WriteString(c.New(c.Underline).Sprintf("%s\n", website))
	fmt.Printf(buf.String())
	return nil
}

func printFileInfoList(files []FileInfo) {
	table := tablewriter.NewWriter(os.Stdout)
	table.SetHeader([]string{"Id", "Name", "Content Type", "Created At", "Size"})
	table.SetBorders(tablewriter.Border{Left: true, Top: false, Right: true, Bottom: false})
	table.SetCenterSeparator("|")
	for _, file := range files {
		table.Append([]string{file.FileId, file.FileName, file.ContentType,
			time.Unix(0, file.CreatedAt).Format(time.RFC822), utils.ByteCountSI(file.FileSize)})
	}
	table.Render()
}
